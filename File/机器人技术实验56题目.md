

## 机器人技术实验56题目

球员的类型-60是球员的编号

因为枚举类型从60开始

play on 模式表示 if ( WM->isBallKickable()){}

23题有对所有球员的遍历

在本方角球的情况下

else if (WM->isCornerKickUs()) {}

在本方界外球的情况下

else if(WM->isOffsideUs()) { }



这里表示随机一点

```c++
VecPosition pos(-(ball.getX())/fabs(ball.getX()) * 5 + ball.getX(),         
-(ball.getY())/fabs(ball.getY()) * 5 + ball.getY()); 
```

// 拿球后行为，利用已有 WorldmodelWorldmodel（21）
(1)在 playOn 模式下，拿到球 以后朝前方快速带。

```C++
soc=dribble(0.0,DRIBBLE_FAST);//0.0表示向前方，第二个参数是带球方式
```

(2)在 PlayOn 模式下，拿到球 以后朝门方向慢速带。

```C++
AngDeg ang=(VecPosition(52.5,0.0)-posAgent).getDirection();//获得球门方向
soc=dribble(ang,DRIBBLE_SLOW);
```

(3)在 playOn 模式下，拿到球以后把围绕自己身体逆时针转 。

```c++
soc=kickBallCloseToBody(-30);//逆时针转动
```

(4)在 playOn 模式下， 拿到球后， 有人逼抢 (自身周围 7米范围 有至少 1名对 方 球员 )，则把球踢到距离对手的另外一侧，安全 带球（如对手在右侧，把球踢到左侧 ，如对手在左侧，把球踢到右侧）。

```c++
Circle cir(posAgent,7);//以智能体所在位置为圆心，自身范围为7创建一个圆  ，posagent表示当前执行代码的球员本身
int num=WM->getNrInSetInCircle(OBJECT_SET_OPPONENTS,cir);//获得在这个圆内对手的数量
AngDeg ang=0;
if(num>0){
 //获得距离球员最近的对手对象
 ObjectT o=WM->getClosestInSetTo(OBJECT_SET_OPPONENTS,posAgent);
 //获得对象所在的位置   
 VecPosition p=WM->getGlobalPosition(o);
 //当>=0时说明p(对手)在球员的顺时针方向即右侧   
 if((p-posAgent).getDirection()>=0){
 	ang+=45;//对手在球员右侧，向左侧带球
  	soc=dribble(ang,DRIBBLE_WITHBALL);
 }
 else{
 	ang-=45;//对手在球员左侧，向右侧带球
	soc=dribble(ang,DRIBBLE_WITHBALL);
 }
}
else{
 //向球门方向带球   
 AngDeg ang=(VecPosition(52.5,0.0)-posAgent).getDirection();
 soc=dribble(ang,DRIBBLE_WITHBALL);
}

```

(5)在 playOn 模式下，拿到球以后，有人逼抢，传球给最近的队友；否则向球门
方向快速带球 。

```c++
Circle cir(posAgent,7);
int num=WM->getNrInSetInCircle(OBJECT_SET_OPPONENTS,cir);
if(num>0) {
    //有人逼抢获取离自己最近的队员进行传球,传球的
    soc=leadingPass(WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,posAgent),1);
    //参数1表示将球传递到距离被传球队员大约1m的位置
}
else{
	AngDeg ang=(VecPosition(52.5,0.0)-posAgent).getDirection();
	soc=dribble(ang,DRIBBLE_FAST);
}

```



(6)在 playOn 模式下，如果 有人逼抢 (自身周围 7米范围有至少 1名对方球员 )， 则安全带球；否则向门方快速 带球。

```C++
Circle cir(posAgent,7);
//获得这个圆形内对手球员的个数
int num=WM->getNrInSetInCircle(OBJECT_SET_OPPONENTS,cir);
AngDeg ang=(VecPosition(52.5,0.0)-posAgent).getDirection();
if(num>0) 
	soc=dribble(0.0,DRIBBLE_WITHBALL); //安全带球
else
	soc=dribble(ang,DRIBBLE_FAST);

```

(7)在 PlayOn 模式下， 若前方没有对方球员，则直接以最大速度 向对方 球门 射门 （周期数为偶，球门 的右侧射奇向的左侧射门）。

```C++
AngDeg ang = (VecPosition(52.5,0.0)-posAgent).getDirection(); 
//该函数计算出球门正前方100米处是否有对方球员
if(WM->isOpponentAtAngle(ang,100)==false){

VecPosition posGoal( PITCH_LENGTH/2.0, (-1 + 2*(WM->getCurrentCycle()%2)) * 0.4 * SS->getGoalWidth() ); //交替进攻球门的下方或者上方

 soc = kickTo( posGoal, SS->getBallSpeedMax() ); 

}

```

(8)在 playOn 模式下 ，拿到球 后，在本方半场 踢到球场中心点 ；过了半场 ，快速 带球到对方球门 。

```C++
if(WM->getBallPos().getX()<0) //如果在我方半场
 	soc=kickTo(VecPosition(0,0),1.0);//将球以速度1.0踢向球场中心点
else{
 AngDeg ang=(VecPosition(52.5,0)-posAgent).getDirection();
 soc=dribble(ang,DRIBBLE_FAST);//向球门方向快速带球之前一定要知道方向因为带球的参数是一个角度
}

```

(9)在 PlayOn 模式下，拿到球后，把传给最近的周围没人防守的队友（没有人防
守以其周围 5米范围是否有对方球员为准）脚下。

```C++
//以离自己最近的球员为圆心，5m为半径画圆
Circle cir(WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,posAgent),5);
int num=WM->getNrInSetInCircle(OBJECT_SET_OPPONENTS,cir);
if(num==0)
 //以速度1.0将球传给这个球员
 soc=leadingPass(WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,posAgent),1.0);
else soc=dribble(0.0,DRIBBLE_WITHBALL);
//否则向前带球
```

(10)在 playOn 模式下，拿到球后，把球传给最靠近自己的前方的没人防守的
队友（判断身边 5米范围是否有对方防守队员）。

```C++
Circle cir(WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,posAgent),5);
int num=WM->getNrInSetInCircle(OBJECT_SET_OPPONENTS,cir);
//获得最靠近自己球员的坐标
VecPosition diff=WM->getGlobalPosition(WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,posAgent));
AngDeg ang=(diff-posAgent).getDirection();//获得两个球员间的角度
if(num==0&&ang>=-90&&ang<=90)//判断是否在前方且没人防守
	soc=leadingPass(WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,posAgent),1.0);
else 
	soc=dribble(0.0,DRIBBLE_WITHBALL);

```

(11)在 playOn 模式下，拿到球以后，在本方半场传给次近的队友；在对方
半场，非 10 号球员传给 10 号球员， 10 号球员则快速向门方带球。

```C++
//当在我方半场
if(WM->getBallPos().getX()<0)
 //找到次近的队友   
 soc=leadingPass(WM->getSecondClosestInSetTo(OBJECT_SET_TEAMMATES,WM->getAgentObjectType()),1.0);
else{                              //也就是我方的10号球员
 	if(WM->getPlayerNumber()!=10)  //我的类型减去60就是编号
  		soc=leadingPass(OBJECT_TEAMMATE_10,1.0);
 	else 
 		soc=dribble((VecPosition(52.5,0.0)-posAgent).getDirection(),DRIBBLE_FAST);
}
```

(12)在 playOn 模式下，如果在本方半场，则朝前方慢速带球，如果在对方半
场，则朝球 门快速带球。

```C++
if(WM->getBallPos().getX()<0)
 	soc=dribble(0.0,DRIBBLE_SLOW);
else 
	soc=dribble((VecPosition(52.5,0.0)-posAgent).getDirection(),DRIBBLE_FAST);
```

(13)在 playOn 模式下，拿到球后 ，如果是 2号，则把球踢到左侧边 线，如果
是 5号，则把球踢到右侧边线，并把脖子方向转向球；其他球员则向前带球。

```c++
//整个球场宽度为68，左侧边界为-34，右侧边界34
if(WM->getPlayerNumber()==2)
 soc=kickTo(VecPosition(WM->getBallPos().getX(),-34),1.0);
else if(WM->getPlayerNumber()==5)
{
  soc=kickTo(VecPosition(WM->getBallPos().getX(),34),1.0);
  //把脖子转向球也就是一直看着球
  ACT->putCommandInQueue(turnNeckToObject(OBJECT_Ball,soc));     
}
 
else soc=dribble(0.0,DRIBBLE_WITHBALL);
```

(14)在 playOn 模式下 ，拿到球后 ，如果 4号，则传球给 7号; 否则的话 ，传 球给最近的队友 ；到对方禁区后以最大速度射向空隙的球门一侧 。

```C++
//到达对方禁区
if(WM->isInTheirPenaltyArea(WM->getBallPos())) { 
 //获得对手守门员的位置
 VecPostion posGoalie=WM->getGlobalPosition(WM->getOppGoalieType()); 
 //获得球员与守门员之间的角度
 AngDeg ang_goalie=(posGoalie-posAgent).getDirection(); 
 //获得向上的角度
 AngDeg angup=(VecPosition(52.5,6.0)-posAgent).getDirection(); 
 //获得向下的角度
 AngDeg angdown=(VecPosition(52.5,-6.0)-posAgent).getDirection();

 if(std::fabs(angup-ang_goalie)>std::fabs(angdown-ang_goalie))  //std中含有一些标准函数这个函数用来计算绝对值
 //如果向上射门的角度>向下射门的角度
  soc=kickTo(VecPosition(52.5,6.0),SS->getBallSpeedMax());
 //则向上以最大速度射门
 else  
  soc=kickTo(VecPosition(52.5,-6.0),SS->getBallSpeedMax()); 
} 

if(WM->getPlayerNumber()==4) 

 soc=leadingPass(OBJECT_TEAMMATE_7,1.0); 

else leadingPass(WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,posAgent),1.0);  

```

(15)在playOn模式下，拿球后垂直带球。

```C++
//球在下半场向上90角度带球
if(WM->getBallPos().getY()<=0) soc=dribble(90,DRIBBLE_WITHBALL); 
//球在上半场向下-90度带球
else soc=dribble(-90,DRIBBLE_WITHBALL);

```

(16)在playOn模式下，拿到球后带球到达球场中心；在球场中心附近位置（中心位置周围2米半径范围内）传给最近的球员。 

```c++
//如果拿球的队员到球场中心的位置>2.0则向球场中心跑去
if(posAgent.getDistanceTo(VecPosition(0,0)>2.0)) { 
 AngDeg ang=(VecPosition(0,0)-posAgent).getDirection();
 soc=dribble(ang,DRIBBLE_WITHBALL); 
}
//到球场中心范围内传给最近的球员
else  
	soc=leadingPass(WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,posAgent),1.0); 
```

(17)在playOn模式下，如果10号控球，则其带球前进，然后5号跟着10号一起前进，两球员在同一水平线上，且距离为5。

```c++
//如果不是10号球员将球传给10号球员

if(WM->getPlayerNumber()!=10) 

 soc=leadingPass(OBJECT_TEAMMATE_10,1.0); 
//如果是10号球员
else soc=dribble(0.0,DRIBBLE_SLOW); 


if(WM->getPlayerNumber()==5) { 

 VecPosition pos=(WM->getBallPos().getX()-5,WM->getBallPos().getY()); 

 soc=moveToPos(pos,20); //当这个点与球员角度之间角度<20的时候转向

}

```

(18)在playon模式下，如果是10号球员，在可踢球的状态下，如果自身的x轴坐标大于30，则直接朝着离对方球员远的球门点射门。 

```c++
if ( WM->isBallKickable())
{
    if(WM->getPlayerNumber()==10&&posAgent.getX()>30)
    {
        VecPosition posGoalie=WM->getGlobalPosition(WM->getOppGoalieType());
        AngDeg ang_goalie=(posGoalie-posAgent).getDirection();
        AngDeg angup=(VecPosition(52.5,6.0)-posAgent).getDirection();
        AngDeg angdown=(VecPosition(52.5,-6.0)-posAgent).getDirection();
     if(std::fabs(angup-ang_goalie)>std::fabs(angdown-ang_goalie))
        soc=kickTo(VecPosition(52.5,6.0),SS->getBallSpeedMax());//朝着距离对方球员远的球门点进行射门
     else
        soc=kickTo(VecPosition(52.5,-6.0),SS->getBallSpeedMax());
    }
}
```

(19)在playOn模式下，如果是9号拿到球，则令9号和10号同时冲至敌方球门处，在球门前，9号传给10号，由10号进行射门 

```C++
 //如果不是9号球员  也可以使用getNumber函数
if(WM->getAgentObjectType()!=OBJECT_TEANMATE_9) { 
 //将球传给9号球员
  soc=leadingPass(OBJECT_TEAMMATE_9,1.0); 
 //获得球门方向的角度
  AngDeg ang=(VecPositoin(52.5,0)-posAgent).  getDirection(); 
 //向球门快速带球
  soc=dribble(ang,DRIBBLE_FAST);

}
//同时10号球员向球门方向前进
if(WM->getAgentObjectType()==OBJECT_TEANMATE_10) 
     soc=moveToPos(VecPosition(52.5,0),20)；
//到达球门正前方传球给10号球员  也就是到达禁区位置
if(WM->isInTheirPenaltyArea(WM->getBallPos())){

  soc=leadingPass(OBJECT_TEAMMATE_10,1.0); 

} 
//10号球员进行射门
if(WM->getAgentObjectType()==OBJECT_TEANMATE_10){ 

  soc=kickTo(VecPosition(52.5,0),SS->getBallSpeedMax())；
 } 

```

(20)在playOn模式下，如果我是4号球员并且拿到了球，则传给7号球员，同时7号球员再传给9号球员，9号球员继续以最大速度冲到球门处射门。 

```c++
if(WM->isBallKickable())
{
    if(WM->getPlayerNumber()==4)
    {
        soc=leadingPass(OBJECT_TEAMMATE_7,1); 
    }
   if(WM->getPlayerNumber()==7) //一个表示对象，另一个表示的是球员的编号

     soc=leadingPass(OBJECT_TE1AMMATE_9,1); 

   if(WM->getPlayerNumber()==9)
   {
        if(WM->getBallPos().getX()!=52.5) //球门的位置 
        {
            soc=dribble((VecPosition(52.5,0)-posAgent).getDirection(),DRIBBLE_FAST); 
        }
       //到达球门处进行射门
        else soc=kickTo(VecPosition(52.5,0),SS->getBallSpeedMax())
   }    
}

 

```

(21)在playOn模式下，如果在我方半场拿到球，则向中场线以最大的速度踢，如果在敌方半场拿到球，则向敌方球门处以最大的速度踢

```c++
//当在我方半场
if(WM->getBallPos().getX()<=0){
 VecPosition pos(0,WM->getBallPos().getY());//计算出中场线的坐标
 soc=kickTo(pos,SS->getBallSpeedMax());//朝中场线踢
}else 
	soc=kickTo(VecPosition(52.5,0),SS->getBallSpeedMax());
//在对方半场向球门处以最大速度踢球
```



// 拿球后行为,自己添加WorldModel函数

(22)在playOn模式下，拿球后传球给更靠近对方球门的最近队友。

```c++
if ( WM->isBallKickable())
{
    soc=leadPass(WM->getClosestInSetTo(OBJECT＿SET＿TEAMMATES,WM->getPosOpponentGoal()),1.0);//更加靠近对方球门的球员
}
```

(23)在playOn模式下，拿球后，搜索前方-30~30之间距离自己20米内是否有队友，如果有则传给该队友，否则自己带球。  

```c++
//WorldModel.cpp
ObjectT WorldModel::getTeammateAtAngleEx(AngDeg angA, AngDeg angB, double dDist)

{

  VecPosition posAgent = getAgentGlobalPosition();

  VecPosition posTeam;

  AngDeg angTeam;

  int iIndex;
  //遍历所有的本方队员
  for(ObjectT o = iterateObjectStart(iIndex,OBJECT_SET_TEAMMATES);
     o != OBJECT_ILLEGAL;
     o = iterateObjectNext(iIndex,OBJECT_SET_TEAMMATES))
  {
   //获得当前坐标   
   posTeam = getGlobalPosition(o);
   //获得我和被遍历的teammate的之间的角度
   angTeam = (posTeam - posAgent).getDirection();

   if(angA <= angTeam && angTeam <= angB && posAgent.getDistanceTo(posTeam) < dDist)
   //当前o代表的本方队员在范围angA-angB之间且距离我的距离小于dDist
    return o;

  }

  iterateObjectDone(iIndex);
  //否则返回未找到这个对象
  return OBJECT_ILLEGAL;

}

  //Playerteam.cpp
  if ( WM->isBallKickable())          

   {

    double ang = (VecPosition(52.5,0)-posAgent).getDirection();//获得我和球门之间的夹角也就是正前方的位置

       ObjectT o = WM->getTeammateAtAngleEx(ang-30, ang, 20);//在-30  -   30之间
       //存在一个队员
       if( o != OBJECT_ILLEGAL)

       {
        soc = leadingPass(o,1);
       }

       else 

       {
        soc = dribble(ang, DRIBBLE_SLOW);//自己朝着球门带球
       }
   }

```



(24)在playon模式下，求出y轴等于0的两侧的对方球员数量，将球传向对手少的一方，并且x轴值最大的队友。

```C++
//WorldModel.cpp下
ObjectT WorldModel::getMaxXTeammateInSide(bool isOwnSize)//isOwnSize参数表示上半场的对手球员数目多或少，为真则多
{
    int iIndex;
    ObjectT maxMate = OBJECT_ILLEGAL;
    for (ObjectT  o = iterateObjectStart(iIndex, OBJECT_SET_TEAMMATES);
                          o != OBJECT_ILLEGAL;
                          o = iterateObjectNext(iIndex, OBJECT_SET_TEAMMATES))
//遍历球场上的所有队员，将结果存放在o中
        {
            VecPosition oPos = getGlobalPosition(o);//获得o的坐标
            if((isOwnSize && oPos.getY() >= 0) ||
                 (!isOwnSize && oPos.getY() <= 0))//上半场人多需要将球传到下半场的球员脚下
            {
                if (maxMate == OBJECT_ILLEGAL || oPos.getX() > getGlobalPosition(maxMate).getX())
                     maxMate = o;
            }    
        }      
        iterate ObjectDone(iIndex);//遍历结束
        return maxMate;//返回这个球员对象
}
 //以下函数作用是返回哪边的球员数量多  如果为true则y>0的区域对方球员的数量在上半场多，反之在下半场对方球员多
 bool   WorldModel:: isOwnSideOpponentMost()
 {
    int ownSideCount = 0;
    int count = 0;      
    int iIndex;
    ObjectT maxMate = OBJECT_ILLEGAL;
    for (ObjectT  o = iterateObjectStart(iIndex, OBJECT_SET_OPPONENTS);
                          o != OBJECT_ILLEGAL;
                          o = iterateObjectNext(iIndex, OBJECT_SET_OPPONENTS))

     {
         if (getGlobalPosition(o).getY() > 0)
             ownSideCount++;//上半场对手球员数目
         count++;//遍历的总球员数
     }
     return ownSideCount > count - ownSideCount;//上半场球员数>下半场时返回真
 }

 //PlayerTeams.cpp  
else if( WM->isBallKickable())
{
    ObjectT mate = WM->getMaxXTeammateInSide(WM->isOwnSideOpponentMost());
    soc = leadingPass(mate, 1);//传给这个球员对象
    ACT->putCommandInQueue(soc);

    ACT->putCommandInQueue( turnNeckToObject(OBJECT_BALL,soc));

    return soc; 

}
```

(25)在playon模式下，如果自身7米范围内有两个或两个以上的对手的话，则传球到x轴值最大的队友。

```C++
//在WorldModel类中添加
ObjectT WorldModel::getMaxXTeammate(){ 

  int iIndex; 

  ObjectT maxMate = OBJECT_ILLEGAL; 

  for (ObjectT o = iterateObjectStart(iIndex, OBJECT_SET_TEAMMATES); 

             o != OBJECT_ILLEGAL; 

             o = iterateObjectNext(iIndex, OBJECT_SET_TEAMMATES)) { 

       VecPosition oPos = getGlobalPosition(o); 

         if (maxMate == OBJECT_ILLEGAL || oPos.getX() > getGlobalPosition(maxMate).getX())

           maxMate = o;     } 

     iterateObjectDone(iIndex); 

     return maxMate; 

}
//cpp

if ( WM->isBallKickable())  

{

      Circle cir(posAgent, 7); 

     int num = WM->getNrInSetInCircle(OBJECT_SET_OPPONENTS, cir); 

     if (num >= 2) {

         ObjectT mate = WM->getMaxXTeammate(); 

          soc = leadingPass(mate, 1); 
     } 
}
```

***(26)在playon模式下，求出己方的越位线，存在可以踢球的队友的话，如果自身是10号。那么10球员垂直跑向越位线的x轴值-2米，y轴不变的点。 

```C++
if(WM->isBallInOurPossesion() && WM->getPlayerNumber==10) 
​     soc=moveToPos(WM->getOffsideX()-2,posAgent.getY(),20); 
可能是正解考试按这个来写
//WorldModel.cpp

//：：表示作用域
double WorldModel::getLastTeammateDefenderX(double *dX)
{
    double dHighestX=0.0;
    double dSecondX=0.0,x;
    ObjectT o,oLast=OBJECT_ILLEGAL,oSecondLast=OBJECT_ILLEGAL;
    for(int i=0;i<MAX_TEAMMATES;i++)
    {
        o=Teammates[i].getType();
        if(isCOnfidenceGood(o))
        {
            x=Teammates[i].getGlobalPosition().getX();
            if(x>dHighestX)
            {
                dSecondX=dHightestX;
                dHightestX=x;
                oSecondLast=oLast;
                oLast=o;
            }
            else if(x>SecondX)
            {
                dSecondX=x;
                oSecondLast=o;
            }
        }
    }
    if(dHightestX<PENALTY_X&&getOwnGoalieType()==OBJECT_ILLGAL)
    {
        dSecondX=dHighestX;
        oSecondLast=oLast;
    }
    if(dX!=Null)
    {
        *dX=dSecondX;
    }
    return (WM->getGlobalPositon(oSecondLast))->getX();
}
//Playerteam.cpp
if(WM->isBallKickable())
{
    if(WM->isBallInOurPossesion() && WM->getPlayerNumber==10) //第一个参数表示判断球是否由我方队员掌控
      soc=moveToPos((WM->getLastTeammateDefenderX()-2,posAgent.getY()),20); //跑向所要求的点
}
```

(27)在playon的模式下，求出球运动方向（即求出其对应的直线方程），并且求出自己到该直线的距离，如果距离小于4的话，那么就垂直跑向该条直线。

```c++
if(isBallKickable())
{
    Line ballRun = Line::makeLineFromPositionAndAngle(WM->getBallPos(), WM->getBallDirection());//求出球的运动方向，传入参数是一个点和角度然后通过这两个值计算出直线方程 
//计算出该条直线到达Agent的距离
if (ballRun.getDistanceWithPoint(WM->getAgentGlobalPosition()) < 4){
//垂直跑向这条直线，也就是找到这条线上某一点到达这个Agent的最短
 soc = moveToPos(ballRun.getPointOnLineClosestTo(WM->getAgentGlobalPosition()), 20); 
}
```

(28)在playon的模式下，如果是自己可以踢球的状态下，如果自身7米内没有对方球员的话，则快速带球，带球方向是朝着点（53,0）方向。 

```c++
Circle cir(posAgent,7); 

int num=WM->getNrInSetInCircle(OBJECT_SET_OPPONENTS,cir); 

AngDeg ang=(VecPosition(53,0)-posAgent).getDirection(); 

if(num>0) //有对方球员 
 soc=dribble(0,DRIBBLE_WITHBALL); 

else //朝着53，0方向带球
 soc=dribble(ang,DRIBBLE_FAST);

```

(29)在playon的模式下，如果距离球最近的是我方队友的话，如果我的x坐标小于30的话，并且我是10号，那么我跑向球的坐标加上（0,10）的坐标位置。

```c++

if(WM->isBallInOurPossesion() && WM->getPlayerNumber==10 && posAgent.getX()<30)
{
    VecPosition pos=WM->getBallPos()+VecPosition(0,10); 
    soc=moveToPos(pos,20);
}
   

```

(30)在playon的模式下，发现前方没有队友的时候，如果自身5米内有两个及两个以上的对手的话，那么将球传给最近的队友。

```c++
//在worldmodelHighLevel.cpp中：仿照isOppenentAtAngle

bool WorldModel::isTeammateAtAngle( AngDeg angA , AngDegB，double dDist  ){  

VecPosition posAgent  = getAgentGlobalPosition();//获得自身的位置

  VecPosition posTeam;

  AngDeg   angTeam;

  int     iIndex;

  for ( ObjectT o = iterateObjectStart( iIndex, OBJECT_SET_TEAMMATES ); o != OBJECT_ILLEGAL; o = iterateObjectNext ( iIndex, BJECT_SET_TEAMMATES ) )  
  {
    posTeam  = getGlobalPosition( o );//获得我这个队友的位置坐标
    angTeam = ( posTeam - posAgent ).getDirection() ;//获得队友与我的角度，ang是球门与我的角度
    if(angA<=angTeam&&angTeam<=angB&&posAgent.getDistanceTo(posTeam)<dDist)
    {
        return true;//在这个角度范围内有队友
    }
  }

  iterateObjectDone( iIndex );

  return false;//前方没有队友

}

//在playerTeams.cpp中：

if(WM->isBallKickable())
{
   Circle cir(posAgent,5);

   int num=WM->getNrInSetInCircle(OBJECT_SET_OPPONENTS,cir);

   AngDeg ang = (VecPosition(52.5,0)-posAgent).getDirection();

   if(WM->isTeammateAtAngle(ang-45,ang+45,10)==false && num>=2)//在前方
   {
      soc=leadingPass(WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,posAgent),1.0);
   }
    
}

```

(31)在 playon 的模式下，发现前方没有对方球员的时候，则快速向球门方向带球，距离守门员5-10米时向空隙较大的一侧射门。

```c++
if(isBallKickable())
{
    AngDeg ang = (VecPosition(52.5,0)-posAgent).getDirection();

​       if(WM->isOpponentAtAngle(ang,20)==false){

​        soc = dribble(ang,DRIBBLE_FAST);

​       }       

​       VecPosition posOppGoalie = WM->getGlobalPosition(WM->getOppGoalieType());

​       double dist = posOppGoalie.getDistanceTo(posAgent);

​       if(dist >= 5 &&dist <= 10)

​       {

​         AngDeg ang_goalie=(posOppGoalie-posAgent).getDirection();

 

​         AngDeg angup=(VecPosition(52.5,6.0)-posAgent).getDirection();

 

​         AngDeg angdown=(VecPosition(52.5,-6.0)-posAgent).getDirection();

 

​        if(fabs(angup-ang_goalie)>fabs(angdown-ang_goalie))

​         soc=kickTo(VecPosition(52.5,6.0),SS->getBallSpeedMax());

​        else 

​         soc=kickTo(VecPosition(52.5,-6.0),SS->getBallSpeedMax());

​       }

}
```

(32)在 playon 的模式下，如果在对方禁区内就射门，否则，如果是7号球员就向球门方向带球，其他球员就将球传给7号。

```c++
if(isBallKickable())
{
    VecPosition opp=WM->getPosOppoentGoal();//获得对方球门的坐标
    
    if(WM->isInTheirPenaltyArea(WM->getBallPos())) //如果球在对方禁区中 
    {
        soc=kick(opp.getDirection(),SS->getBallSpeedMax());
    }
    else
    {
        if(WM->getNumber()==7)
        {
            soc=dribble(opp.getDirection(),DRIBBLE_WITHBALL);  //安全带球
        }
        else
        {
            soc=leadingPass(OBJECT_TEAMMATE_7,1.0);
        }
    }
}
```

(33)在 playon 的模式下，（8，9，10，11）前方没有对方球员的时候，则快
速向球门方向带球，距离守门员 5-10 米时向空隙较大的一侧射门。

```c++
else if (WM->isBallKickable()) // if kickable // 如果球已知，而且当前球在我脚下(可踢)
 {
  int number = WM->getPlayerNumber();//获得球员的编号
  if (number >= 8 && number <= 11){
   AngDeg ang = (VecPosition(52.5, 0) - posAgent).getDirection();
   if (WM->isOpponentAtAngle(ang, 20) == false){
    soc = dribble(ang, DRIBBLE_FAST);
   }
   VecPosition posOppGoalie = WM->getGlobalPosition(WM->getOppGoalieType());
   double dist = posOppGoalie.getDistanceTo(posAgent);
   if (dist >= 5 && dist <= 10){
   		AngDeg ang_goalie = (posOppGoalie - posAgent).getDirection();
   		AngDeg angup = (VecPosition(52.5, 6.0) - posAgent).getDirection();
   		AngDeg angdown = (VecPosition(52.5, -6.0) - posAgent).getDirection();
    if (fabs(angup - ang_goalie) > fabs(angdown - ang_goalie))
		soc = kickTo(VecPosition(52.5, 6.0), SS->getBallSpeedMax());
    else
		soc = kickTo(VecPosition(52.5, -6.0), SS->getBallSpeedMax());
   }
  }
 }

```

// 其他比赛模式下，进攻行为其他比赛模式下，进攻行为（8） 

(34)在本方角球模式下，如果自己是 10 号球员，则跑向角球点，并开球（球可踢，则踢球给9号）；如果自己是9号球员，则跑向距离角球点附近（随机选一点），准备接应球，其他球员跑本位点. 

```c++
else if (WM->isCornerKickUs()) 

{

   if (WM->getAgentObjectType() == OBJECT_TEAMMATE_10) 

  { 

​    if (WM->isBallKickable()) 

​      soc = leadingPass(OBJECT_TEAMMATE_9, 1); 

​    else 

​      soc = moveToPos(WM->getBallPos(), PS->getPlayerWhenToTurnAngle()); 

  } 

  if (WM->getAgentObjectType() == OBJECT_TEAMMATE_9)  {

​    VecPosition ball = WM->getBallPos(); 

​    VecPosition pos(-(ball.getX())/fabs(ball.getX()) * 5 + ball.getX(), 

​            -(ball.getY())/fabs(ball.getY()) * 5 + ball.getY()); 

​    soc = moveToPos(pos, PS->getPlayerWhenToTurnAngle()); 

  }
    ACT->putCommandInQueue( soc );

    ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) ); 
}

```

(35)在本方界外球模式下，如果自己是距离球最近的队员，跑向球；并开球（球可踢，则把球传给最近的队友）。

```c++
else if(WM->isOffsideUs()) { 

  if(WM->getFastestInSetTo( OBJECT_SET_TEAMMATES, OBJECT_BALL, &iTmp ) 

​         == WM->getAgentObjectType()) 
  { 
     //球可踢
​    if(WM->isBallKickable()) {

​       ObjectT objTea =WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,WM->getAgentObjectType(),&dist); 

​       

​      soc=leedingpass(objTea,1.0); 

​    }
     //球不可踢
​    else { 

​      soc=moveToPos(WM->getBallPos(),20);

​    } 

​    ACT->putCommandInQueue(soc); 

  } 

}

```

(36)在本方界外球模式下，在本方半场左侧，则由 2 号去发；如果是本方半场右侧，则由5号去发；球在2号或者5号脚下，则踢向距离自己最近的队友。

```c++
else if(WM->isOffsideUs()) { 

  VecPosition posBall=WM->getBallPos(); 

  if((posBall.getX()<0 && posBall.getY()<0 && WM->getPlayerNumber()==2)||

​      ((posBall.getX()<0 && posBall.getY()>0 && WM->getPlayerNumber()==5)))  { 

​    if(WM->isBallKickable()) {

​      ObjectT objTea =WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,WM->getAgentObjectType(),&dist); 

​      VecPosition posTea=WM->getGlobalPosition(objTea); 

​      soc=kickTo(posTea,SS->getBallSpeedMax()); 

​    }else {

​      soc=moveToPos(WM->getBallPos(),20); 

​    } 

​    ACT->putCommandInQueue(soc);

  } 

}
```

(37) 在本方界外球的模式下，如果我是距离球第二近的队友的话，那么我也朝着球的位置跑，直到距离球7米的范围。

```c++
else if(WM->isOffsideUs()){ 

 ObjectT o=WM->getSecondClosestInSetTo(OBJECT_SET_TEAMMATES,OBJECT_BALL) ; 

 double myPosx=WM->getAgentGlobalPosition().getX(); 

 double myposy=WM->getAgentGlobalPosition().getY(); 

 double ballposx=WM->getBallPos().getX(); 

 double ballposy=WM->getBallPos().getY(); 

 double dis=sqrt(pow(ballposx-myPosx,2)+pow(ballposy-myposy,2)); 

 if(WM->getAgentObjectType()==o&&dis>7) {

  soc=moveToPos( VecPosition(ballposx,ballposy ) , 20 ); 

  ACT->putCommandInQueue( soc ); 

 } 

}

```

(38)在本方界外球的模式下，如果我是 4 号的话，并且距离球最近的队友不是我，那么我将跑向球的坐标加上（5,0）的位置上去。 

```c++
else if(WM->isOffsideUs()){

if((WM->getPlayerNumber()==4)&&(WM-> getClosestInSetTo( OBJECT_SET_TEAMMATES, OBJECT_BALL)!=OBJECT_TEAMMATE_4)) 

  soc=moveToPos((WM->getBallPos()+VecPosition(5,0)),20); 

  ACT->putCommandInQueue( soc ); // 放入命令队列 

  ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) ); 

}

```

(39)在本方界外球的模式下，如果我是距离球第二近的队友，那么我跑向距离球 12 米的范围内，并且距离对方球门点（52.5,0）最近的点。 ![](C:\Users\12074\Pictures\Screenshots\公式1.png)

![](C:\Users\12074\Pictures\Screenshots\公式2.png)

```c++
else if ( WM->isOffsideUs() ){ 

  ObjectT o = WM -> getSecondClosestInSetTo(OBJECT_SET_TEAMMATES , OBJECT_BALL) ; 

  if ( WM ->getAgentObjectType() == o ) { 

      //由于需要跑到距离对方球门最近的点也就是球门中心点与以球为圆心12为半径的圆交点
      double ballx = WM->getBallPos().getX() ; 

      double bally = WM->getBallPos().getY() ; 

      double k ,b1 ,deita, x1, x2, y1, y2;;
      // 计算以球为圆心，12为半径的圆与对方球门线（x=52.5）的交点

       k=bally/( ballx-52.5);// 计算交点所在直线的斜率 设y=kx+b1

       b1=0-k*52.5;//计算出截距(代入球门的坐标(52.5,0))       也就是y=tx+m;之后联立两个方程
        //即：(x-ballx)*2+(y-bally)*2=144 与直线 y=kx+b1
      
      //这个式子的结果推导如图
      

       deita = pow(2*k*b1 - 2*ballx - 2*k*bally, 2) - 4*(pow(k, 2) + 1)*(pow(b1, 2) + pow(ballx, 2) + pow(bally, 2) - 144);
      

       x1 = (-(2*k*b1 - 2*ballx - 2*k*bally) + sqrt(deita)) / (2*(pow(k, 2) + 1));
       x2 = (-(2*k*b1 - 2*ballx - 2*k*bally) - sqrt(deita)) / (2*(pow(k, 2) + 1));

       y1 = k*x1 + b1;

       y2 = k*x2 + b1;

       double y ,x; 

       if( y1<y2){ 

        y=y1 ;x=x1; 

       }

       else 

      	 y=y2;x=x2; 

       soc = moveToPos( VecPosition( x,y) ,20); 

  } 

  ACT->putCommandInQueue( soc ); // 放入命令队列 

}

```

(40)在本方界外球的模式下，距离球最近的队友跑向球并开球，如果我不是距离球第二近的队友，那么我向球的坐标方向跑去。 

```c++
else if ( WM->isOffsideUs( )){
 ObjectT o1 = WM->getClosestInSetTo( OBJECT_SET_TEAMMATES , OBJECT_BALL) ; //获得离球最近的对象
 if( WM->getAgentObjectType() == o1 ) 
 { 
  if( WM->getGlobalPosition( o1) != WM->getBallPos() ) 
      soc = moveToPos( WM->getBallPos() ,20) ; //若距离球最近的对象o1不在球的位置
  else  {
      //在球的位置
   ObjectT o3 = WM->getClosestInSetTo( OBJECT_SET_TEAMMATES ,posAgent) ; 
   soc = leadingPass( o3 , 1) ;//如果这个球员在球处传球给离球最近的队员
  }
 }
 ObjectT o2 = WM->getSecondClosestInSetTo(OBJECT_SET_TEAMMATES , OBJECT_BALL) ; 
 if( WM->getAgentObjectType() != o2){ 
     VecPosition pos=WM->getBall();
      soc = moveToPos( pos,20) ; 
 }
   ACT->putCommandInQueue( soc );  
}

```

(41)在本方界外球的模式下，距离球最近的队友跑向球并开球。如果我不是距离球第二近的队友，那么求出距离球第二近的队友的坐标加上（10，5）的点；如果该点在球场内，则跑向该点，如果该点在场外，则计算距离该点最近的边界点。

```c++
else if(WM->isOffsideUs()){ 

 ObjectT o1=WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,OBJECT_BALL) ; //距离球最近的

 ObjectT o2=WM->getSecondClosestInSetTo(OBJECT_SET_TEAMMATES,OBJECT_BALL) ; //距离球第二近的

 double o2Posx;//距离球第二近的x坐标 

 double o2posy; //距离球第二近的y坐标

 o2Posx=WM->getGlobalPosition(o2).getX(); 

 o2posy=WM->getGlobalPosition(o2).getY(); 

 if (WM->getAgentObjectType()==o1 ) { 

  if(WM->getGlobalPosition(o1)!=WM->getBallPos())  {

   soc=moveToPos(WM->getBallPos(),20); //如果我不在球的位置我跑向球的位置并且开球

  } 

  else {
      //我在球的位置那么我传球给距离我最近的队员

   ObjectT o3 = WM->getClosestInSetTo( OBJECT_SET_TEAMMATES , o1) ; 

     soc = leadingPass(o3,1); 

  }

 } 

  if(WM->getAgentObjectType()!=o1&&WM->getAgentObjectType()!=o2)  { 

      if(o2Posx+10<=52.5&&o2posy+5<=34)
      {
          soc=moveToPos(VecPosition(o2Posx+10,o2posy+5),20); 
      }
      else
      {
          VecPosition closest=WM->getClosestInsetTo(VecPosition(o2Posx+10,o2posy+5));
      }
   

  }

 ACT->putCommandInQueue( soc );  

}

 

```

//playOn模式下，防守行为模式，防守行为（8） 

(42)在playOn模式下，5号球员与拿球的对方球员的距离始终为5。

```c++
if(WM->getPlayerNumber()==5) {
 	VecPosition pos(WM->getBallPos().getX()-5,WM->getBallPos().getY());
    soc=moveToPos(pos,20);
}
```

(43)在playOn模式下，2号和4号一起去盯防对方拿球队员。

```c++
if(isBallInOurPossesion==false)//不是我方球员控球
{
    if(WM->getAgentObjectType()==OBJECT_TEAMMATE_2){
 VecPosition pos(WM->getBallPos().getX()-5,WM->getBallPos().getY());
 soc=moveToPos(pos,20);
}
if(WM->getAgentObjectType()==OBJECT_TEAMMATE_4){
 VecPosition pos(WM->getBallPos().getX(),WM->getBallPos().getY()-5)
 soc=moveToPos(pos,20);
} 
    
}


```

(44)在playOn模式下，如果对方10号拿球，如果我是2、3、4号，则去盯防10号。

```c++

//球对我来说不可以踢
int num=WM->getPlayerNumber();
//如果是对方10号球员拿球说明对方10号球员离球最近
if(WM->getClosestInSetTo(OBJECT_SET_OPPONENTS,WM->getBallPos())==OBJECT_OPPONENT_10&&
  (num==2||num==3||num==4)){
    //盯防球员
  VecPosition pos=WM->getMarkingPosition(OBJECT_OPPONENT_10,2.0,MARK_BALL);
  soc=moveToPos(WM->getGlobalPosition(OBJECT_OPPONENT_10),PS->getPlayerWhenToTurnAngle());
  ACT->putCommandInQueue( soc );
}

```

(45)在playOn模式下，如对方9号拿球，我方2、3、4号距离球最近的球员去盯防9号，其他队员盯防距离自己最近的对方球员 

```c++
if(WM->getClosestInSetTo(OBJECT_SET_OPPONENTS,WM->getBallPos())==OBJECT_OPPONENT_9){
 ObjectT closestObject=OBJECT_TEAMMATE_2;
 VecPosition team=WM->getGlobalPosition(closestObject);
 double minDis=team.getDistanceTo(WM->getGlobalPosition(OBJECT_OPPONENT_9));
 team=WM->getGlobalPosition(OBJECT_TEAMMATE_3);
 double dis=team.getDistanceTo(WM->getGlobalPosition(OBJECT_OPPONENT_9));
 if(dis<minDis) {
  minDis=dis;
  closestObject=OBJECT_TEAMMATE_3;
 }
 team=WM->getGlobalPosition(OBJECT_TEAMMATE_4);
 dis=team.getDistanceTo(WM->getGlobalPosition(OBJECT_OPPONENT_9));
 if(dis<minDis){
 	closestObject=OBJECT_TEAMMATE_4;
 }
 if(WM->getAgentObjectType()==closestObject){
     //第一个参数表示想要标记的对象  第二个参数表示期望被标记对象与O也就是盯防队员之间的距离
     //第三个参数表示这种类型的盯人很难接到传球
  VecPosition pos=WM->getMarkingPosition(OBJECT_OPPONENT_9,2.0,MARK_BALL);
  soc=moveToPos(pos,PS->getPlayerWhenToTurnAngle());
 }
 else {
  ObjectT opp=WM->getClosestInSetTo(OBJECT_SET_OPPONENTS,WM->getAgentObjectType());
  VecPosition oppPos=WM->getMarkingPosition(opp,2.0,MARK_BALL);
  soc=moveToPos(oppPos,40);
 }
}
```

(46)在playOn模式下，如果对方比我先接近球，则离球最近的队员去盯球，其他球员盯防距离自己最近的对方球员。

```c++
//在worldModel.cpp中添加
bool WorldModel:: isOpponentCloserToBall(){
 ObjectT opp=getFastestInSetTo(OBJECT_SET_OPPONENTS,OBJECT_BALL);
 double oppDisToBall=getGlobalPosition(opp).getDistanceTo(getBallPos());
 ObjectT teammate=getFastestInSetTo(OBJECT_SET_TEAMMATES,OBJECT_BALL);
 double teammateDisToBall=getGlobalPosition(teammate).getDistanceTo(getBallPos());
 if(oppDisToBall<teammateDisToBall)
	return true;
 else
  	return false;
}
//Player.cpp
//如果对方球员更靠近球
if(WM-> isOpponentCloserToBall()){
    //获得离（对方离球最近的成员）最近的队员信息
 
    ObjectT teammate=WM->getClosestInSetTo(OBJECT_SET_OPPONENTS,WM->getBallPos());
    //当我是离球最近的队员时
    if(WM->getAgentObjectType()==teammate) {
        soc=moveToPos(WM->getBallPos(),PS->getPlayerWhenToTurnAngle());
 }
 else {
  ObjectT opp=WM->getClosestInSetTo(OBJECT_SET_OPPONENTS,WM->getAgentObjectType());
  VecPosition oppPos=WM->getMarkingPosition(opp,2.0,MARK_BALL);
  soc=moveToPos(oppPos,PS->getPlayerWhenToTurnAngle());
 }
} 

```

(47)在playOn模式下，如果对方11号拿到球，则7号球员从左边去断球，8号球员从右边去断球。

```c++
//对方11号拿到球意味11号队员离球最近
if(WM->getClosestInSetTo(OBJECT_SET_OPPONENTS,WM->getBallPos())==OBJECT_OPPONENT_11){
	VecPosition oppPos=WM->getGlobalPosition(OBJECT_OPPONENT_11);
 if(WM->getPlayerNumber()==7){
	VecPosition selfPos=WM->getGlobalPosition(OBJECT_TEAMMATE_7);
    double dis=selfPos.getDistanceTo(oppPos);
  if(dis>5){
      //如果和对方11号球员之间的距离大于5则去到距离4的位置断球也就是左边
   soc=moveToPos(VecPosition(oppPos.getX(),oppPos.getY(-4),40);
  }
  else{
      //否则进行断球，参数表示能否进行断球   isGoalie为true时不可断球，反之可以断球
  	soc=intercept(0);
  }
 }
 else if(WM->getPlayerNumber()==8){
  VecPosition selfPos=WM->getGlobalPostion(OBJECT_TEAMMATE_8);
  double dis=selfPos.getDistanceTo(oppPos);
  if(dis>5){
   soc=moveToPos(VecPosition(oppPos.getX(),oppPos.getY()+4),40);//去往右边进行断球
  }else{
	soc=intercept(0);
  }
 }
}

```

(48)在playOn模式下，防守模式下（即球不在我方球员脚下），我方6号球员始终跟着敌方9号，我方7号始终跟着敌方10号，8号球员始终跟着敌方11号球员。

```c++
if(!WM->isBallInOurPossesion()){
 if(WM->getAgentObjectType()==OBJECT_TEAMMATE_6) {
	  VecPosition pos=WM->getGlobalPosition(OBJECT_OPPONENT_9);
	  soc=moveToPos(pos,40);
 }
 if(WM->getAgentObjectType()==OBJECT_TEAMMATE_7){
  VecPosition pos=WM->getGlobalPosition(OBJECT_OPPONENT_10);
  soc=moveToPos(pos,40);
 }
 if(WM->getAgentObjectType()==OBJECT_TEAMMATE_8){
  VecPosition pos=WM->getGlobalPosition(OBJECT_OPPONENT_11);
  soc=moveToPos(pos,40);
 }
  ACT->putCommandInQueue( soc ); // 放入命令队列
  ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
}

```

(49)在playOn模式下，防守模式下（即球不在我方球员脚下），我方距离球最近的2名队员负责去盯防对方离球最近的球员，其他球员采用人球都盯的方式盯防距离自己最近的对方球员（即跑到距离自己最近的对方球员的可能接球路线的前面位置点）

```c++
if(!WM->isBallInOurPossesion()){
         //获得离球最近的对方球员对象
         ObjectT closestOpp = WM->getClosestInSetTo(OBJECT_SET_OPPONENTS, OBJECT_BALL);
         //获得我方离球最近和第二近的球员对象
         ObjectT closestTeam = WM->getClosestInSetTo(OBJECT_SET_TEAMMATES, OBJECT_BALL);
         ObjectT secondClosestTeam = WM->getSecondClosestInSetTo(OBJECT_SET_TEAMMATES, OBJECT_BALL); 
         //获得一个球员对象
         ObjectT agent = WM->getAgentObjectType();
         if(agent==closestTeam || agent==secondClosestTeam){
          //如果是距离球最近的两个队员，盯防距离球最近的队员               参数可以直接拦截传球路线
          VecPosition oppPos=WM->getMarkingPosition(closestOpp,2.0,MARK_BISECTOR);
          soc=moveToPos(oppPos,PS->getPlayerWhenToTurnAngle());
        }
         else{
          //剩下的球员去盯防离自己最近的球员
          ObjectT opp=WM->getClosestInSetTo(OBJECT_SET_OPPONENTS,WM->getAgentObjectType());
          VecPosition oppPos=WM->getMarkingPosition(opp,2.0,MARK_BALL);
          soc=moveToPos(oppPos,40);
        }
      }

```

//其他比赛模式下，防守行为其他比赛模式下，防守行为（7） 

(50) 在对方界外球的模式下，如果我是 4 号，那么我就跑向距离球最近的对方球员处。

```c++
else if(WM->isOffSideThem()){
  if(WM->getPlayerNumber()==4){
      ObjectT opp=WM->getCloesestInsetTo(OBJECT_SET_OPPONENTS,OBJECT_BALL);
      VecPosition pos=WM->getGlobalPosition(opp);
      soc=moveToPos(pos,PS->getPlayerWhenToTurnAngle())
  }
  ACT->putCommandInQueue( soc );
 }

```

(51) 在对方界外球的模式下，如果我是距离球第二近的队员的话，那么我跑向距离球第二近的对方球员的位置。

```c++
else if(WM->isOffSideThem()){
  if(WM->getSecondClosestInSetTo(OBJECT_SET_TEAMMATES,OBJECT_BALL)==WM->getAgentObjectType()){
      ObjectT opp=WM->getSecondClosestInSetTo(OBJECT_SET_OPPONENTS,OBJECT_BALL);
      VecPosition pos=WM->getGlobalPosition(opp);
      soc=moveToPos(pos,PS->getPlayerWhenToTurnAngle());
  }
  ACT->putCommandInQueue( soc );
}

```

(52)在对方角球模式情况下，如果球在我方左侧，则2，3，6，7号平均分布在以球的位置为圆心，半径10米的圆弧上（其中2号的初始位置可以自行设定，间距也可以自行设定，但是需要保证2，3，6，7都在场内）；如果球在我方右侧，则4，5，7，8号平均分布在以球的位置为圆心，半径10米的圆弧上（其中4号的初始位置可以自行设定，间距也可以自行设定，但是需要保证4，5，7，8都在场内）。

```c++
if(WM->isCornerKickThem()){
             const double Pi = 3.1415926;
             int num = WM->getPlayerNumber();
             if(WM->getBallPos().getY()<0){
				if(num == 2){
                	soc = moveToPos(VecPosition(-42.5,34.0), 40);//移动到距离球门10米的边界线上
			    }
              	else if(num == 3){
                    //由于球的位置为(-52.5,34)
					soc = moveToPos(VecPosition(-52.5+10*cos(Pi/6),34.0-10*sin(Pi/6)), 40);
              	}
	            else if(num == 6){
		            soc = moveToPos(VecPosition(-52.5+10*cos(2*Pi/6),34.010*sin(2*Pi/6)), 40);
	            }	
                else if(num == 7){
		            soc = moveToPos(VecPosition(-52.5+10*cos(3*Pi/6),34.0-10*sin(3*Pi/6)), 40);
                }
             }
             else if(WM->getBallPos().getY()>0){
              if(num == 4){
               soc = moveToPos(VecPosition(-42.5,-34.0), 40);
              }
              else if(num == 5){
               soc = moveToPos(VecPosition(-52.5+10*cos(Pi/6),-34.0+10*sin(Pi/6)), 40);
              }
			  else if(num == 7){
               soc = moveToPos(VecPosition(-52.5+10*cos(2*Pi/6),-34.0+10*sin(2*Pi/6)), 40);
              }
              else if(num == 8){
               soc = moveToPos(VecPosition(-52.5+10*cos(3*Pi/6),-34.0+10*sin(3*Pi/6)), 40);
              }
             }
             ACT->putCommandInQueue( soc ); // 放入命令队列
             ACT->putCommandInQueue ( turnBodyToObject ( OBJECT_BALL ) );
            //ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) ); // 把脖子转向球，也就是一直看着球
            }

```

(53)在对方界外球的模式下，如果我不是距离球最近的队友，并且我的 x 轴坐标大于0的话，那么我跑向自身位置加（-10,0）的点的位置去。

```c++
else if(WM->isOffSideThem())
{
if(WM->getClosestInSetTo(OBJECT_SET_TEAMMATES,OBJECT_BALL)!=WM->getAgentObjectType()
		 && WM->getAgentGlobalPosition().getX()>0){
	  soc=moveToPos(VecPosition(-10,0)+WM->getAgentGlobalPosition(),20);
  }
  ACT->putCommandInQueue( soc );
  }

```

(54)在对方界外球的模式下，如果我身边 5 米内有对方球员的话，那么我跑向身边对方球员的位置，并且我的x轴坐标的值要比该对方的大2。

```c++
else if ( WM->isOffsideThem() ){
   Circle cir ( posAgent , 5 ) ;
   int num = 0 ;
   num = WM->getNrInSetInCircle( OBJECT_SET_OPPONENTS , cir ) ;
   if ( num != 0 ){
      ObjectT o = WM->getClosestInSetTo( OBJECT_SET_OPPONENTS , posAgent) ;
      VecPosition poso = WM->getGlobalPosition(o ) ;
      VecPosition pos( poso.getX() + 2 , poso.getY() ) ;
      soc = moveToPos( pos , 20 ) ;
   }
   ACT->putCommandInQueue( soc ); 
} 

```

(55)在对方界外球的模式下，如果球的位置的 x 轴小于 0，如果我是 4 号或 5号的话，一起跑向距离球第二近的对方球员的位置。

```c++
else if ( WM->isOffsideThem()){
 if (WM->getBallPos().getX()<0&&( WM -> getPlayerNumber()==4 || WM->getPlayerNumber()==5 )){
      ObjectT o = WM -> getSecondClosestInSetTo( OBJECT_SET_OPPONENTS ,OBJECT_BALL ) ;
      VecPosition  posopptwo = WM ->getGlobalPosition( o ) ;
      soc = moveToPos( posopptwo , 20 ) ;
      ACT->putCommandInQueue( soc );
 }
}

```

(56)在对方角球模式情况下，如果球在我方左侧，则2，3号负责盯防对方距离球第二近的对方球员；如果球在我方右侧，则4，5号负责盯防对方距离球第二近的对方球员。

```c++
if(WM->isCornerKickThem()){
             ObjectT opp=WM->getSecondClosestInSetTo(OBJECT_SET_OPPONENTS,OBJECT_BALL);
             int num = WM->getPlayerNumber();
             if(WM->getBallPos().getY()<0 && (num == 2 || num == 3)){
              VecPosition oppPos=WM->getMarkingPosition(opp,2.0,MARK_BALL);
              soc=moveToPos(oppPos,40);
             }
             else if(WM->getBallPos().getY()>0 && (num == 4 || num == 5)){
              VecPosition oppPos=WM->getMarkingPosition(opp,2.0,MARK_BALL);
              soc=moveToPos(oppPos,40);
             }
             ACT->putCommandInQueue( soc ); // 放入命令队列
             ACT->putCommandInQueue ( turnBodyToObject ( OBJECT_BALL ) );
            //ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) ); // 把脖子转向球，也就是一直看着球
}

```

```c++
SoccerCommand Player::deMeer5(  )
{

    SoccerCommand soc(CMD_ILLEGAL);// 定义一个命令对象，后面会频繁用它来构造一个球员动作命令
    VecPosition   posAgent = WM->getAgentGlobalPosition();// 一个点对象，表示Agent(可以理解成当前在执行这个代码的球员它自己)的位置
    ///下面我们把“我“就理解成当前执行这个代码的Agent，因为有11个球员在执行这个代码，所以对于每个球员 肯定有一个“我”存在。
    VecPosition   posBall  = WM->getBallPos();// 球的位置
    VecPosition   posGoal  = WM->getPosOpponentGoal();// 球的位置
    int           iTmp;


    if ( WM->isBeforeKickOff( ) ) /// 如果还没有开球 注意！ 这里只是还没有开球的情况！ 要做开球后的决策，向下面继续找另外一个 WM->isBeforeKickOff( )
    {
        if ( WM->isKickOffUs( ) && WM->getPlayerNumber() == 9 ) // 9 takes kick //就找9号去开球（判断了是不是我们开球，和我"Agent"是不是9号）
        {
            if ( WM->isBallKickable() )// 当球对于我来说是不是可踢！
            {
		    VecPosition posGoal(PITCH_LENGTH/2.0, 
				       (-1 + 2*(WM->getCurrentCycle()%2)) * 
				       0.4 * SS->getGoalWidth());
		    soc=kickTo( posGoal,SS->getBallSpeedMax());// 朝球门方向将球以最大力度踢
// 		else 
// 		{
// 		    if(WM->getAgentObjectType()==OBJECT_TEAMMATE_9 )//|| 
// 		      //WM->getAgentObjectType()==OBJECT_TEAMMATE_8 || 
// 		      //WM->getAgentObjectType()==OBJECT_TEAMMATE_7) 
// 		    {
// 		      soc=dribble(0.0,DRIBBLE_SLOW); //带球 
// 		    }
// 		    else 
// 		      soc=leadingPass(OBJECT_TEAMMATE_9,1);//传球 		
// 		}
// 		ACT->putCommandInQueue(soc); 
// 		ACT->putCommandInQueue(turnNeckToObject(OBJECT_BALL,soc));

            }
            else //如果球对于我不可踢，那我就去抢球！
            {
                soc = intercept( false );
                Log.log( 100, "move to ball to take kick-off" );
            }
            ACT->putCommandInQueue( soc );
            ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
            return soc;
        }
    
    else if( WM->isCornerKickUs())//我方角球
    {
	if(WM->isBallKickable() )
	{
	    soc = kickTo(pointKickTo(), SS->getBallSize()*0.8);
	}
	else if(WM->getFastestInSetTo( OBJECT_SET_TEAMMATES, OBJECT_BALL, &iTmp)
	  == WM->getAgentObjectType())
	{
	    soc = moveToPos(posBall, PS->getPlayerWhenToTurnAngle());
	}
	else if(WM->getSecondClosestInSetTo(OBJECT_SET_TEAMMATES, OBJECT_BALL)
	  == WM->getAgentObjectType())
	{
	    soc = moveToPos(pointKickToC(), PS->getPlayerWhenToTurnAngle());
	}
	else
	{
	    soc = moveToPos(WM->getStrategicPosition(), PS->getPlayerWhenToTurnAngle());
	}
	
	ACT->putCommandInQueue( soc ); // 放入命令队列
    ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
    }
    else  /// 这个else 大家应该可以知道，是开球以后的决策！ 也就是最重要的比赛正常模式下的决策！ 很重要，我们就从这里开始！！！！ Start！
    {
        formations->setFormation( FT_334_OFFENSIVE );//设置球队进攻阵型
        soc.commandType = CMD_ILLEGAL;//初始化soc命令对象

        ///test SoccerCommand(CMD_DASH, 80, 45) for v14 ... fixed by misol.gao
       /* if ( WM->getPlayerNumber() == 8 )
        {
			soc = SoccerCommand(CMD_DASH, 80, 45);
            ACT->putCommandInQueue( soc ); // 放入命令队列
            ACT->putCommandInQueue( alignNeckWithBody() );
            return soc;
        }*/

        if ( WM->getConfidence( OBJECT_BALL ) < PS->getBallConfThr() )//判断对球的可信度，如果小于某个阈值，则...也就是说，如果很多周期没有看到球在哪里了
        {
            ACT->putCommandInQueue( soc = searchBall() );   // if ball pos unknown //执行找球动作！并放入命令队列
            ACT->putCommandInQueue( alignNeckWithBody( ) ); // search for it //同时把脖子随身体一起转
        }
        else if ( WM->isBallKickable())                   // if kickable // 如果球已知，而且当前球在我脚下(可踢)
        {   
	    else//默认策略
	    {
		VecPosition posGoal(PITCH_LENGTH/2.0, 
				       (-1 + 2*(WM->getCurrentCycle()%2)) * 
				       0.4 * SS->getGoalWidth());
		soc=kickTo( posGoal,SS->getBallSpeedMax());// 朝球门方向将球以最大力度
	    }

            ACT->putCommandInQueue( soc ); // 放入命令队列
            ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) ); // 把脖子转向球，也就是一直看着球
            Log.log( 100, "kick ball" );
        }
        else if ( WM->getFastestInSetTo( OBJECT_SET_TEAMMATES, OBJECT_BALL, &iTmp )
                  == WM->getAgentObjectType()  && !WM->isDeadBallThem() ) // 如果球不在我的控制范围下，但是当前能最快抢到球的是我，那我就去执行抢球动作
        {                                                // if fastest to ball
            Log.log( 100, "I am fastest to ball; can get there in %d cycles", iTmp );
            soc = intercept( false );                      // intercept the ball
            if ( soc.commandType == CMD_DASH &&            // if stamina low  // 这里是对体力的一个保护，体力过低就把Dash的dPower减小 保护体力
                    WM->getAgentStamina().getStamina() <
                    SS->getRecoverDecThr()*SS->getStaminaMax()+200 )
	      {
                soc.dPower = 32.0 * WM->getAgentStamina().getRecovery(); // dash slow
                ACT->putCommandInQueue( soc );
                ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
	      }
	      else                                           // if stamina high
	      {
                ACT->putCommandInQueue( soc );               // dash as intended
                ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
	      }
	      
	    }
        else if ( posAgent.getDistanceTo(WM->getStrategicPosition()) >
                  1.5 + fabs(posAgent.getX()-posBall.getX())/10.0) // 到了这里就是其他距离球相对远一点的人了，如果离自己的阵形点太远，就跑回 自己的阵形点去。
            // if not near strategic pos
        {
            if ( WM->getAgentStamina().getStamina() >    // if stamina high
                    SS->getRecoverDecThr()*SS->getStaminaMax()+800 )
            {
                soc = moveToPos(WM->getStrategicPosition(),
                                PS->getPlayerWhenToTurnAngle());
                ACT->putCommandInQueue( soc );            // move to strategic pos
                ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
            }
            else                                        // else watch ball
            {
                ACT->putCommandInQueue( soc = turnBodyToObject( OBJECT_BALL ) );
                ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
            }
        }
        else if ( fabs( WM->getRelativeAngle( OBJECT_BALL ) ) > 1.0 ) // watch ball //其他剩下的球员呢，就看球。！
        {///这里就是无球队员的跑位决策

            ACT->putCommandInQueue( soc = turnBodyToObject( OBJECT_BALL ) );
            ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
        }
        else                                         // nothing to do
            ACT->putCommandInQueue( SoccerCommand(CMD_TURNNECK,0.0) );
    }
    return soc;
}

/*!This method is a simple goalie based on the goalie of the simple Team of
   FC Portugal. It defines a rectangle in its penalty area and moves to the
   position on this rectangle where the ball intersects if you make a line
   between the ball position and the center of the goal. If the ball can
   be intercepted in the own penalty area the ball is intercepted and catched.
*/
SoccerCommand Player::deMeer5_goalie(  )
{
    int i;
    SoccerCommand soc;
    VecPosition   posAgent = WM->getAgentGlobalPosition();
    AngDeg        angBody  = WM->getAgentGlobalBodyAngle();

    // define the top and bottom position of a rectangle in which keeper moves
    static const VecPosition posLeftTop( -PITCH_LENGTH/2.0 +
                                         0.7*PENALTY_AREA_LENGTH, -PENALTY_AREA_WIDTH/4.0 );
    static const VecPosition posRightTop( -PITCH_LENGTH/2.0 +
                                          0.7*PENALTY_AREA_LENGTH, +PENALTY_AREA_WIDTH/4.0 );

    // define the borders of this rectangle using the two points.
    static Line  lineFront = Line::makeLineFromTwoPoints(posLeftTop,posRightTop);
    static Line  lineLeft  = Line::makeLineFromTwoPoints(
                                 VecPosition( -50.0, posLeftTop.getY()), posLeftTop );
    static Line  lineRight = Line::makeLineFromTwoPoints(
                                 VecPosition( -50.0, posRightTop.getY()),posRightTop );
    
    if ( WM->isBeforeKickOff( ) )
    {
        if ( formations->getFormation() != FT_INITIAL || // not in kickoff formation
                posAgent.getDistanceTo( WM->getStrategicPosition() ) > 2.0 )
        {
            formations->setFormation( FT_INITIAL );       // go to kick_off formation
            ACT->putCommandInQueue( soc=teleportToPos(WM->getStrategicPosition()) );
        }
        else                                            // else turn to center
        {
            ACT->putCommandInQueue( soc = turnBodyToPoint( VecPosition( 0, 0 ), 0 ));
            ACT->putCommandInQueue( alignNeckWithBody( ) );
        }
        return soc;
    }


    if ( WM->getConfidence( OBJECT_BALL ) < PS->getBallConfThr() )
    {                                                // confidence ball too  low
        ACT->putCommandInQueue( searchBall() );        // search ball
        ACT->putCommandInQueue( alignNeckWithBody( ) );
    }
    else if ( WM->getPlayMode() == PM_PLAY_ON || WM->isFreeKickThem() ||
              WM->isCornerKickThem() )
    {
        if ( WM->isBallCatchable() )
        {
            ACT->putCommandInQueue( soc = catchBall() );
            ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
        }
        else if ( WM->isBallKickable() )
        {
            soc = kickTo( WM->getSecondClosestInSetTo(OBJECT_SET_TEAMMATES,OBJECT_TEAMMATE_1), 2.0 );
            ACT->putCommandInQueue( soc );
            ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
        }
        else if ( WM->isInOwnPenaltyArea( getInterceptionPointBall( &i, true ) ) &&
                  WM->getFastestInSetTo( OBJECT_SET_PLAYERS, OBJECT_BALL, &i ) ==
                  WM->getAgentObjectType() )
        {
            ACT->putCommandInQueue( soc = intercept( true ) );
            ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
        }
        else
        {
            // make line between own goal and the ball
            VecPosition posMyGoal = ( WM->getSide() == SIDE_LEFT )
                                    ? SoccerTypes::getGlobalPositionFlag(OBJECT_GOAL_L, SIDE_LEFT )
                                    : SoccerTypes::getGlobalPositionFlag(OBJECT_GOAL_R, SIDE_RIGHT);
            Line lineBall = Line::makeLineFromTwoPoints( WM->getBallPos(),posMyGoal);

            // determine where your front line intersects with the line from ball
            VecPosition posIntersect = lineFront.getIntersection( lineBall );

            // outside rectangle, use line at side to get intersection
            if (posIntersect.isRightOf( posRightTop ) )
                posIntersect = lineRight.getIntersection( lineBall );
            else if (posIntersect.isLeftOf( posLeftTop )  )
                posIntersect = lineLeft.getIntersection( lineBall );

            if ( posIntersect.getX() < -49.0 )
                posIntersect.setX( -49.0 );

            // and move to this position
            if ( posIntersect.getDistanceTo( WM->getAgentGlobalPosition() ) > 0.5 )
            {
                soc = moveToPos( posIntersect, PS->getPlayerWhenToTurnAngle() );
                ACT->putCommandInQueue( soc );
                ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
            }
            else
            {
                ACT->putCommandInQueue( soc = turnBodyToObject( OBJECT_BALL ) );
                ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
            }
        }
    }
    
    else if ( WM->isFreeKickUs() == true || WM->isGoalKickUs() == true )
    {
        if ( WM->isBallKickable() )
        {
            if ( WM->getTimeSinceLastCatch() == 25 && WM->isFreeKickUs() )
            {
                // move to position with lesser opponents.
                if ( WM->getNrInSetInCircle( OBJECT_SET_OPPONENTS,
                                             Circle(posRightTop, 15.0 )) <
                        WM->getNrInSetInCircle( OBJECT_SET_OPPONENTS,
                                                Circle(posLeftTop,  15.0 )) )
                    soc.makeCommand( CMD_MOVE,posRightTop.getX(),posRightTop.getY(),0.0);
                else
                    soc.makeCommand( CMD_MOVE,posLeftTop.getX(), posLeftTop.getY(), 0.0);
                ACT->putCommandInQueue( soc );
            }
            else if ( WM->getTimeSinceLastCatch() > 28 )
            {
                 soc = kickTo( WM->getSecondClosestInSetTo(OBJECT_SET_TEAMMATES,OBJECT_TEAMMATE_1), 2.0 );
		 //soc = clearBall( CLEAR_BALL_DEFENSIVE );
                ACT->putCommandInQueue( soc );
            }
        }
        else if ( WM->isGoalKickUs()  )
        {
            ACT->putCommandInQueue( soc = intercept( true ) );
            ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
        }
        else
            ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
    }
    else
    {
        ACT->putCommandInQueue( soc = turnBodyToObject( OBJECT_BALL ) );
        ACT->putCommandInQueue( turnNeckToObject( OBJECT_BALL, soc ) );
    }
    return soc;
}
```

1. **理论知识**：通过学习，你可能对RoboCup2d有了深入的理解，包括其背后的机器人技术、算法和策略等。
2. **实践技能**：通过在UVA_Base_2003文件下更改代码完成自己的球队建设的实验，你可能提高了编程能力，尤其是在机器人技术领域的编程能力。
3. **团队合作**：如果这个课程需要团队合作完成实验，那么你可能也提高了团队协作能力。
4. **问题解决**：在解决实验中遇到的问题时，你可能提高了问题解决能力。

对于线上课程的建议，可能包括：

1. **互动环节**：可以增加更多的互动环节，比如讨论区、在线问答等，以增加学生参与度。
2. **实时反馈**：提供实时反馈机制，让学生可以及时了解自己的学习进度和理解程度。
3. **资源共享**：提供相关的学习资源，如参考书籍、教程、示例代码等。
4. **实验指导**：对于实验部分，可以提供更详细的指导，帮助学生更好地完成实验。



1. **基本Linux命令的学习**：这是实验的基础部分，你需要掌握如何在Linux环境下进行操作，包括文件管理、权限设置、进程管理等。
2. **了解demeer5的实验原理**：你需要理解demeer5的工作原理，包括它的结构、功能以及如何与其他系统或模块交互。
3. **学会对demeer5进行简单的修改操作**：在理解了demeer5的原理之后，你将学习如何对其进行修改，以满足特定的需求或实现特定的功能。
4. **完成一些复杂动作的编写**：这部分将需要你运用所学知识，编写一些复杂的动作或行为。这可能包括编写新的算法、优化现有代码等。

为了帮助你更好地完成这些实验，我建议你：

1. **深入理解Linux命令**：Linux命令是实验的基础，你需要熟练掌握各种常用命令。可以找一些在线教程或书籍进行学习。
2. **详细阅读demeer5的文档**：理解demeer5的工作原理是进行有效修改的关键。你应该详细阅读相关文档，并尝试理解其背后的逻辑。
3. **多做实践**：通过不断地实践，你可以更好地理解和掌握知识。当遇到问题时，不要急于求解，而是应该尝试自己寻找答案。
4. **寻求帮助**：如果在实验过程中遇到困难，不要犹豫向老师或同学求助。他们可能会给你提供不同的视角和解决方法。

希望这些建议能对你有所帮助！





```python
class BaseMessage:
    def __init__(self):
        self.HearMessage = ""
        self.SeeMessage = ""

    # 初步获取信息，将信息分割成hear和see两块
    def GetHearandLearn(self, MyMessage):

            if MyMessage.index("hear")<MyMessage.index("see"):
                self.HearMessage = MyMessage[MyMessage.index("hear") - 1: MyMessage.index("see") - 1]  # 截取字符串
                self.HearMessage = self.HearMessage.strip()  # 删除头尾空白符

                self.SeeMessage = MyMessage[MyMessage.index("see") - 1: len(MyMessage)]
                self.SeeMessage = self.SeeMessage.strip()

            else:
                self.SeeMessage = MyMessage[MyMessage.index("see") - 1: MyMessage.index("hear") - 1]  # 截取字符串
                self.SeeMessage = self.SeeMessage.strip()  # 删除头尾空白符

                self.HearMessage = MyMessage[MyMessage.index("hear") - 1: len(MyMessage)]
                self.HearMessage = self.HearMessage.strip()


def ReturnHear(self):
    # 去除无关信息，将听到的内容格式化，使其以括号组形式存在
    hearMessage = self.HearMessage[self.HearMessage.index("(") + 1: self.HearMessage.rindex(")")]
    # 截取字符串
    # 用空格进行分割 因为经过上面的处理，剩余的信息是() () () 这样括号组以空格分割的形式
    hears = hearMessage.split(" ")
    # 测试
    #print(hears)
    # for i in range(4):
    #     print(hears[i])

    #判断hears[2]位置是否为数字
    try:
        num = float(hears[2])  # 尝试将hears[2]转换为浮点数类型
        result = True  # 如果成功，result为True
    except ValueError:  # 如果发生值错误异常
        result = False  # result为False
    # 如果是数字就需要加方向
    if result:
        print("在" + hears[1] + "周期,hear从" + hears[2] + "方向听到了", end="")
        for i in range(3, len(hears)):
            print(hears[i] + " ", end="")
        print()
    else:
        print("在" + hears[1] + "周期hear从" + hears[2] + "听到了", end ="")
        for i in range(3, len(hears)):
            print(hears[i] + " ", end="")
        print()

def ReturnSee(self):
    # 去除无关信息
    # print(self.SeeMessage)
    seeMessage = self.SeeMessage[self.SeeMessage.index("(", 2) : self.SeeMessage.rindex(")")]
    seeMessage = seeMessage.strip() # 去空格
    # print(seeMessage)
    seetime = self.SeeMessage[5 : self.SeeMessage.index("(", 2) - 1]
    seetime = seetime.strip()
    #print(seetime)
    #以下代码负责进行字符串的截取操作
    messages=[]
    count = 0
    begin = 0
    end = 0
    # 看到了多个信息，每个信息以括号组形式存在,将每个信息提取出来
    for i in range(len(seeMessage)):  # 对seeMessage中的每个信息进行遍历操作
        if count == 0:
            begin = i
        if seeMessage[i] == "(":
            count += 1
        if seeMessage[i] == ")":
            count -= 1
            if count == 0:
                end = i + 1
                messages.append(seeMessage[begin: end])  # 进行截取操作
    #print(messages)
    print("在" + seetime + "周期,see ", end="")
    # print(messages[0])
    # print(messages[2])

    for j in range(len(messages)):
        #打印message信息中的数据
        #print(messages[j])
        #当内容为ball时
        if "ball" in messages[j]: #如果是"ball"在这段信息中，将ball提取出来
            ballmessage = messages[j][messages[j].index(")") + 1: messages[j].rindex(")")].strip().split(" ")
            #测试是否获得这段数据中的每一个信息
            # for i in range(len(ballmessage)):
            #     print(ballmessage[i],end="")
            print(
                f"{messages[j][2:messages[j].index(')')]} 距离我的"
                f"Distance是:{ballmessage[0]},"
                f"Direction是:{ballmessage[1]},"
                f"DistChng是:{ballmessage[2]},"
                f"DirChng是:{ballmessage[3]}"
            )

        #当内容为Player时
        elif "player" in messages[j]:
            # 下面是提取信息源名称后面的信息，如果player
            playermessage = messages[j][messages[j].index(")") + 1 : messages[j].rindex(")")].strip().split(" ")
            # 测试是否获得这段数据中的每一个信息
            # for i in range(len(playermessage)):
            #     print(playermessage[i],end="")
            print(
                f"{messages[j][2:messages[j].index(')')]} 距离我的"
                f"Distance是:{playermessage[0]},"
                f"Direction是:{playermessage[1]},"
                f"DistChng是:{playermessage[2]},"
                f"DirChng是:{playermessage[3]},"
                f"智能体的BodyDir是:{playermessage[4]},"
                f"智能体的HeadDir是:{playermessage[5]}"
            )
        elif"Line"in messages[j]:
            linemessage=messages[j][messages[j].index(")") + 1 : messages[j].rindex(")")].strip().split(" ")
            # print(len(linemessage))
            # for i in range(len(linemessage)):
            #     print(linemessage[i],end="")
            print(
                messages[j][2:messages[j].index(")")]
                +" 和我的角度是: "
                +linemessage[0]
                +"度"
            )

        else:

            mixmessage = messages[j][messages[j].index(")") + 1 : messages[j].rindex(")")].strip().split(" ")
            # 测试是否获得这段数据中的每一个信息
            # print(len(mixmessage))
            # for i in range(len(mixmessage)):
            #     print(mixmessage[i],end="")
            print(
                messages[j][2 : messages[j].index(")")]
                + " 距离我的 Distance 是"
                + mixmessage[0]
                + ", Direction是 "
                + mixmessage[1]
            )




print("测试1")
text1="(hear 1024 referee corner_kick_r)(see 0 ((g r) 64.1 13) ((f r t) 64.5 -16) ((f r b) 79 38) ((f p r t) 46.1 -6) ((f p r c) 48.1 18) ((f p r b) 58 37) ((l r ) 62.8 -89))"
message1=BaseMessage()
message1.GetHearandLearn(text1)
ReturnHear(message1)
ReturnSee(message1)
print()

print("测试2")
text2="(hear 1022 -30 passto(23,24))(see 1022 ((ball) -20 20 1 -2) ((player hfut1 2) 45 23 0.5 1 22 40 ) ((goal r) 12 20) ((Line r) -30))"
message2=BaseMessage()
message2.GetHearandLearn(text2)
ReturnHear(message2)
ReturnSee(message2)
print()
print("测试3")
text3="(see 2022 ((player hfut2 8) 40 23 1 6 21 33 )((goal r) 15 30) ((f r t 20)5 24 ))(hear 2022 -10 “pass ball”)"
message3=BaseMessage()
message3.GetHearandLearn(text3)
ReturnSee(message3)
ReturnHear(message3)

```

