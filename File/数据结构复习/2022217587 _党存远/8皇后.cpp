#include <iostream>
using namespace std;
int n = 8; // 棋盘大小
int ans = 0; // 解的个数
int col[9]; // 列是否被占用
int d1[16]; // 正对角线是否被占用
int d2[16]; // 反对角线是否被占用

void dfs(int row) { // 深度优先搜索  row代表当前行数
    if (row > n) { // 找到一组解     当row超过棋盘数则找到了第一组解
        ans++;
        return;
    }
    for (int i = 1; i <= n; i++) { // 枚举每一列
        if (!col[i] && !d1[row + i] && !d2[row - i + n]) { // 判断是否可以放置皇后
            col[i] = d1[row + i] = d2[row - i + n] = 1; // 标记占用
            dfs(row + 1); // 继续搜索下一行
            col[i] = d1[row + i] = d2[row - i + n] = 0; // 回溯，取消标记
        }
    }
}

/*
* 
dfs 函数是一个深度优先搜索函数，用于递归地寻找符合条件的放置皇后的解。
row 参数表示当前需要考察的行数。
当 row 大于 n 时，即超过了棋盘的最后一行，表示找到了一组解，解的数量 ans 自增，并返回。这里的 ans 变量用于记录解的个数。
for 循环枚举了每一列 i，用于尝试将皇后放置在当前行的不同列。
在判断是否可以放置皇后时，使用了三个辅助数组 col[]、d1[] 和 d2[]：
col[i] 用于标记第 i 列是否已经放置了皇后；
d1[row + i] 用于标记从左上方到右下方的斜线上是否已经放置了皇后；
d2[row - i + n] 用于标记从右上方到左下方的斜线上是否已经放置了皇后。
如果当前列、左上方的斜线和右上方的斜线都没有放置皇后，则可以将皇后放置在此处。
在放置皇后之后，进行标记，并继续递归地搜索下一行（调用 dfs(row+1)）。
如果无法放置皇后会进行回溯，并取消相应位置的占用标记。
*/

int main() {
    dfs(1); // 从第一行开始搜索
    cout << "8皇后问题的解决方案共有";
    cout << ans <<"种"<< endl; // 输出解的个数
    system("pause");
    return 0;
}

