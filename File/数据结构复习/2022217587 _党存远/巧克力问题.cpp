#include <iostream>
#include <cstring>
using namespace std;
const int N = 110;
double f[N][N]; // 状态数组

int main() {
    int c, n, m;
    cin >> c >> n >> m;//c 代表共有c种不同颜色的巧克力，
    f[0][0] = 1;

    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= i; j++) {
            if (j == 0) f[i][j] = f[i - 1][j + 1] * (j + 1) / c;
            else if (j == i) f[i][j] = f[i - 1][j - 1] * (c - j + 1) / c;
            else f[i][j] = f[i - 1][j - 1] * (c - j + 1) / c + f[i - 1][j + 1] * (j + 1) / c;
        }

    cout << f[n][m] << endl;
    return 0;
}


/*如果j == 0，表示盒子里没有同色的巧克力了。这只能发生在我们在上一步吃掉了每种颜色的一块巧克力的情况下。
因此，f[i][0] = f[i - 1] * (1 / c)，这是在吃掉i - 1块巧克力后，还剩下每种颜色一块的概率乘以在当前步骤中选择任意一种颜色的概率。
如果j == i，表示我们吃掉的所有巧克力都是同一种颜色的。
这只能发生在我们在上一步选择了一种新的颜色，并且在当前步骤中继续选择相同的颜色的情况下。
因此，f[i][i] = f[i - 1][i - 1] * ((c - i + 1) / c)，这是在吃掉i - 1块同色巧克力后的概率乘以在当前步骤中选择一种新颜色的概率。
如果0 < j < i，表示我们盒子里有一些同色的巧克力和一些不同颜色的巧克力。
这可以通过两种方式发生：要么我们在上一步选择了一种新的颜色，并且在当前步骤中选择了另一种不同的颜色，
要么我们在上一步选择了一种不同的颜色，并且在当前步骤中选择了相同的颜色。
因此，f[i][j] = f[i - 1][j - 1] * ((c - j + 1) / c) + f[i - 1][j + 1] * ((j + 1) / c)，这是这两种情况的概率之和。
*/
//这段代码的时间复杂度是 O(n^2)，其中 n 是取出的巧克力的数量。这是因为在计算状态数组时，需要枚举所有的状态，总共有 n * n 种状态，每种状态的转移时间复杂度都是 O(1)。

